--// Refactored ESP Library
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

--// Configuration
local ESP = {
    Enabled = false,
    TeamCheck = false,
    WallCheck = false,
    GhostCheck = false,
    AliveCheck = false,
    
    Settings = {
        BoxColor = Color3.fromRGB(255, 255, 255),
        BoxOutlineColor = Color3.fromRGB(0, 0, 0),
        BoxType = "2D", -- "2D" or "Corner"
        
        NameColor = Color3.fromRGB(255, 255, 255),
        ShowName = false,
        
        HealthHighColor = Color3.fromRGB(0, 255, 0),
        HealthLowColor = Color3.fromRGB(255, 0, 0),
        ShowHealth = false,
        
        ShowDistance = false,
        ShowTracer = false,
        TracerColor = Color3.fromRGB(255, 255, 255),
        TracerPosition = "Bottom", -- "Top", "Middle", "Bottom"
        
        ShowSkeletons = false,
        SkeletonsColor = Color3.fromRGB(255, 255, 255),
    }
}

local Cache = {}

--// Constants
local BONES = {
    {"Head", "UpperTorso"}, {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"}, {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"}, {"UpperTorso", "LowerTorso"}, {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"}, {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"}
}

--// Utilities
local function CreateDrawing(class, properties)
    local drawing = Drawing.new(class)
    for prop, val in pairs(properties) do
        drawing[prop] = val
    end
    return drawing
end

local function IsVisible(player, character)
    if not ESP.WallCheck then return true end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {localPlayer.Character, character}
    
    local result = workspace:Raycast(camera.CFrame.Position, (root.Position - camera.CFrame.Position), params)
    return result == nil
end

--// ESP Instance Class
local ESPInstance = {}
ESPInstance.__index = ESPInstance

function ESPInstance.new(player)
    local self = setmetatable({}, ESPInstance)
    self.Player = player
    self.Components = {
        Box = CreateDrawing("Square", {Thickness = 1, Filled = false, ZIndex = 2}),
        BoxOutline = CreateDrawing("Square", {Thickness = 3, Color = Color3.new(0,0,0), Filled = false, ZIndex = 1}),
        Name = CreateDrawing("Text", {Size = 13, Center = true, Outline = true, ZIndex = 2}),
        Distance = CreateDrawing("Text", {Size = 12, Center = true, Outline = true, ZIndex = 2}),
        Tracer = CreateDrawing("Line", {Thickness = 1, Transparency = 1, ZIndex = 2}),
        HealthBar = CreateDrawing("Line", {Thickness = 1, ZIndex = 2}),
        HealthOutline = CreateDrawing("Line", {Thickness = 3, Color = Color3.new(0,0,0), ZIndex = 1}),
        SkeletonLines = {},
        CornerLines = {}
    }
    return self
end

function ESPInstance:Update()
    local player = self.Player
    local char = player.Character
    local components = self.Components
    
    -- Visibility Logic
    local function setAllVisible(state)
        for _, comp in pairs(components) do
            if typeof(comp) == "table" then
                for _, line in pairs(comp) do line.Visible = state end
            else
                comp.Visible = state
            end
        end
    end

    if not ESP.Enabled or not char or (ESP.TeamCheck and player.Team == localPlayer.Team) then
        setAllVisible(false)
        return
    end

    local root = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not root or not hum or (ESP.AliveCheck and hum.Health <= 0) then
        setAllVisible(false)
        return
    end

    local pos, onScreen = camera:WorldToViewportPoint(root.Position)
    if not onScreen or not IsVisible(player, char) then
        setAllVisible(false)
        return
    end

    -- Ghost Check Optimization
    if ESP.GhostCheck and char:FindFirstChild("Head") and char.Head.Transparency > 0.8 then
        setAllVisible(false)
        return
    end

    -- Calculations
    local head = char:FindFirstChild("Head")
    local headPos = camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
    local legPos = camera:WorldToViewportPoint(root.Position - Vector3.new(0, 3, 0))
    
    local height = math.abs(headPos.Y - legPos.Y)
    local width = height * 0.6
    local size = Vector2.new(width, height)
    local position = Vector2.new(pos.X - width/2, pos.Y - height/2)

    -- Box Render
    if ESP.Settings.ShowBox then
        if ESP.Settings.BoxType == "2D" then
            components.Box.Visible = true
            components.BoxOutline.Visible = true
            components.Box.Size = size
            components.Box.Position = position
            components.Box.Color = ESP.Settings.BoxColor
            components.BoxOutline.Size = size
            components.BoxOutline.Position = position
            -- Hide corner lines if they exist
            for _, v in pairs(components.CornerLines) do v.Visible = false end
        else
            -- Corner Box Logic (Simplified for performance)
            components.Box.Visible = false
            components.BoxOutline.Visible = false
            self:UpdateCorners(position, size)
        end
    else
        components.Box.Visible = false
        components.BoxOutline.Visible = false
        for _, v in pairs(components.CornerLines) do v.Visible = false end
    end

    -- Name & Distance
    if ESP.Settings.ShowName then
        components.Name.Visible = true
        components.Name.Text = player.Name:lower()
        components.Name.Position = Vector2.new(pos.X, position.Y - 16)
        components.Name.Color = ESP.Settings.NameColor
    else components.Name.Visible = false end

    if ESP.Settings.ShowDistance then
        components.Distance.Visible = true
        components.Distance.Text = math.floor((camera.CFrame.Position - root.Position).Magnitude) .. "m"
        components.Distance.Position = Vector2.new(pos.X, position.Y + height + 2)
    else components.Distance.Visible = false end

    -- Health Bar
    if ESP.Settings.ShowHealth then
        local healthPct = hum.Health / hum.MaxHealth
        local barHeight = height * healthPct
        
        components.HealthOutline.Visible = true
        components.HealthOutline.From = Vector2.new(position.X - 5, position.Y + height)
        components.HealthOutline.To = Vector2.new(position.X - 5, position.Y)
        
        components.HealthBar.Visible = true
        components.HealthBar.From = Vector2.new(position.X - 5, position.Y + height)
        components.HealthBar.To = Vector2.new(position.X - 5, position.Y + height - barHeight)
        components.HealthBar.Color = ESP.Settings.HealthLowColor:Lerp(ESP.Settings.HealthHighColor, healthPct)
    else
        components.HealthBar.Visible = false
        components.HealthOutline.Visible = false
    end

    -- Tracer
    if ESP.Settings.ShowTracer then
        local targetY = (ESP.Settings.TracerPosition == "Top" and 0) or (ESP.Settings.TracerPosition == "Middle" and camera.ViewportSize.Y / 2) or camera.ViewportSize.Y
        components.Tracer.Visible = true
        components.Tracer.From = Vector2.new(camera.ViewportSize.X / 2, targetY)
        components.Tracer.To = Vector2.new(pos.X, pos.Y)
        components.Tracer.Color = ESP.Settings.TracerColor
    else components.Tracer.Visible = false end

    -- Skeleton Render
    if ESP.Settings.ShowSkeletons then
        self:UpdateSkeleton(char)
    else
        for _, v in pairs(components.SkeletonLines) do v.Visible = false end
    end
end

function ESPInstance:UpdateSkeleton(char)
    local count = 1
    for _, pair in ipairs(BONES) do
        local p1, p2 = char:FindFirstChild(pair[1]), char:FindFirstChild(pair[2])
        if p1 and p2 then
            local pos1, vis1 = camera:WorldToViewportPoint(p1.Position)
            local pos2, vis2 = camera:WorldToViewportPoint(p2.Position)
            
            if vis1 and vis2 then
                local line = self.Components.SkeletonLines[count]
                if not line then
                    line = CreateDrawing("Line", {Thickness = 1, Color = ESP.Settings.SkeletonsColor})
                    self.Components.SkeletonLines[count] = line
                end
                line.Visible = true
                line.From = Vector2.new(pos1.X, pos1.Y)
                line.To = Vector2.new(pos2.X, pos2.Y)
                line.Color = ESP.Settings.SkeletonsColor
                count = count + 1
            end
        end
    end
    -- Hide unused lines
    for i = count, #self.Components.SkeletonLines do
        self.Components.SkeletonLines[i].Visible = false
    end
end

function ESPInstance:UpdateCorners(pos, size)
    -- Utility to manage 8 lines for corners
    if #self.Components.CornerLines == 0 then
        for i = 1, 8 do
            table.insert(self.Components.CornerLines, CreateDrawing("Line", {Thickness = 1, Color = ESP.Settings.BoxColor}))
        end
    end
    
    local lines = self.Components.CornerLines
    local x, y, w, h = pos.X, pos.Y, size.X, size.Y
    local lineLen = w / 4
    
    local points = {
        {Vector2.new(x, y), Vector2.new(x + lineLen, y)},
        {Vector2.new(x, y), Vector2.new(x, y + lineLen)},
        {Vector2.new(x + w, y), Vector2.new(x + w - lineLen, y)},
        {Vector2.new(x + w, y), Vector2.new(x + w, y + lineLen)},
        {Vector2.new(x, y + h), Vector2.new(x + lineLen, y + h)},
        {Vector2.new(x, y + h), Vector2.new(x, y + h - lineLen)},
        {Vector2.new(x + w, y + h), Vector2.new(x + w - lineLen, y + h)},
        {Vector2.new(x + w, y + h), Vector2.new(x + w, y + h - lineLen)}
    }

    for i, p in ipairs(points) do
        lines[i].Visible = true
        lines[i].From = p[1]
        lines[i].To = p[2]
        lines[i].Color = ESP.Settings.BoxColor
    end
end

function ESPInstance:Destroy()
    for _, comp in pairs(self.Components) do
        if typeof(comp) == "table" then
            for _, line in pairs(comp) do line:Remove() end
        else
            comp:Remove()
        end
    end
    self.Components = nil
end

--// Logic Controller
local function AddPlayer(player)
    if player == localPlayer then return end
    Cache[player] = ESPInstance.new(player)
end

local function RemovePlayer(player)
    if Cache[player] then
        Cache[player]:Destroy()
        Cache[player] = nil
    end
end

--// Initialization
Players.PlayerAdded:Connect(AddPlayer)
Players.PlayerRemoving:Connect(RemovePlayer)
for _, p in ipairs(Players:GetPlayers()) do AddPlayer(p) end

RunService.RenderStepped:Connect(function()
    for _, instance in pairs(Cache) do
        instance:Update()
    end
end)

return ESP
